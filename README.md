# ВНИМАНИЕ! Данный проект ныне считается устаревшим. Описание актуальных версий будет дополнено в репозиториях [профиля](https://github.com/zhukov-technologies).

- [Умный дом на основе API Telegram](#smart_home)
- [Прошивка](#firmware)
- - [Безопасность соединений](#secure)
- - - [Соединение сервер-MYEWWT](#server-myewwt)
- - - [Соединение MYEWWT-устройства](#myewwt-device)
- - [Конвертер из Юникода](#unicode)
- - [Структуры для связи по ESP-NOW](#structure)

<a id="smart_home"></a>
# Умный дом на основе API Telegram

Принцип работы системы умного дома zhukov tehcnology на основе API Telegram.

1. Пользователь создаёт своего бота в Telegram при помощи BotFather ([Создание бота в Telegram](https://github.com/zhukov-technologies/zhukov_myewwt_clock#bot)).
2. Получив токен созданного бота, пользователь сообщает устройству ([Miss You Even When We're Together](https://github.com/zhukov-technologies/zhukov_myewwt_clock)) (MYEWWT) токен бота а также SSID и пароль Wi-Fi сети ([Настройка MYEWWT](https://github.com/zbltrz/MYEWWT#myewwt_setup)).
3. Отправляя сообщение боту, оно обрабатывается устройством MYEWWT.
4. Если в систему добавлены дополнительные устройства — умные розетки, реле и т.д., команда от бота обрабатывается сначала устройством MYEWWT, затем передаётся подключенным в систему устройствам с применением технологии [ESP-NOW](https://www.espressif.com/en/products/software/esp-now/overview).

![Frame 44](https://user-images.githubusercontent.com/84660518/156764174-f941a3c9-73b9-44ff-b16c-c1ca3817e657.png)

<a id="firmware"></a>
# Прошивка

Проект начал свое существование в среде Arduino IDE с применением SDK от компании Espressif для микроконтроллера ESP-12F, затем получил развитие в среде VS Code с применением набора инструментов PlatformIO.

Большая часть кода проекта проккоментирована и разбита на удобные части в виде нескольких файлов: 
* основная, с общим циклом и объявлением глобальных переменных и некоторых функций,
* для функций, вызываемых при отправке и приеме сообщений через [ESP-NOW](https://www.espressif.com/en/products/software/esp-now/overview),
* функции, используемые для работы адресных светодиодов,
* блок с функциями для работы сервера ([captive portal](https://ru.wikipedia.org/wiki/Captive_portal)),
* функция-обработчик сообщений с бота Telegram,
* блок с прочими системнымми функциями: отсчёт времени, обвновление прошивки, синхронизация времени и т.д.


<a id="secure"></a>
## Безопасность соединений

В системе умного дома zhukov technologies используются два типа соединений:

1. От сервера Telegram к шлюзу MYEWWT.
2. От шлюза MYEWWT к прочим устройствам системы (розетки, реле, выключатели и т.д.).

<a id="server-myewwt"></a>
### Соединение сервер-MYEWWT

Все аспекты безопасности самого API Telegram, а конкретно защита профиля, защита чатов и т.д. описаны [здесь](https://core.telegram.org/#security).

Между серверами Telegram и MYEWWT устанавливается соединение по защищённому каналу связи, это гарантирует протокол SSL, т.е. сами сервера Telegram не дают возможности подключиться и получить запрос от бота, без использования SSL шифрования. 

В коде прошивки благодаря [BearSSL](https://bearssl.org/) (реализация протокола SSL на языке C) создаётся клиент, с помощью которого мы имеем возможность получать и отправлять запросы к API Telegram, конкретно к указанному в прошивке (при настройке MYEWWT) боту. 

Чтобы другой пользователь, получивший ссылку на бота под управлением MYEWWT или обнаружив его в поиске не смог получить доступ к нему, в коде прошивки создаётся white list, где находятся ID пользователей. ID — уникальный номер аккаунта в Telegram, его невозможно подделать и изменить. Таким образом, при настройке MYEWWT, доступ получает первый человек, обратившийся к боту, его ID сохраняется в энергонезависимой памяти, и возможность обмена сообщений закрепляется за данным пользователем, сообщения от других пользователей просто отсеиваются. 

Также в коде прошивки есть возможность выдать правда доступа к MYEWWT другим пользователям — достаточно в настройках выбрать меню "Добавить пользователя" и указать его ID.

Подводя итог, можно сделать вывод о безопасности подобного соединения. Чтобы иметь несанкционированный доступ к боту — придется получить доступ к аккаунту владельца MYEWWT, что сделать довольно сложно, а при должных настройках безопасности Telegram профиля — практически невозможно.

<a id="myewwt-device"></a>
### Соединение MYEWWT-устройства

Внутри дома прочие устройства, такие как розетки, реле, выключатели и т.д. не подключены к Wi-Fi и не связаны с интернетом (за исключеним попыток связи с сервером для обновления прошивки раз в n часов)

Связь между MYEWWT и другими устройствами передаётся с помощью [ESP-NOW](https://www.espressif.com/en/products/software/esp-now/overview) — встроенного в SDK от Espressif метода передачи данных. Данное соединение одноранговое, не требует времязатратного "рукопожатия" а также обеспечено возможностью применения протокола [CCMP](https://ru.wikipedia.org/wiki/CCMP), алгоритма [AES-128](https://ru.wikipedia.org/wiki/AES_(%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82_%D1%88%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)).
Связь между устройствами устанавливается посредством отправки пакета на MAC-адрес устройства, либо с использованием широковещательной передачи. 

В документации указано ограниченное число соединений:

Максимум 20 пар, включая зашифрованные, поддерживаются на одном устройстве, включая зашифрованные пары.
Максимум 10 зашифрованных пар поддерживаются в режиме Station.
Максимум 6 в режиме SoftAP или SoftAP + Station.

А также указано о необходимости регистрации устройств на этапе компиляции прошивки:
```cpp
 esp_now_add_peer(broadcastAddress, ESP_NOW_ROLE_COMBO, 1, NULL, 0);
  ```

Несмотря на это, было установлено, что без выполнения подобных рекомендаций, можно ограничиться лишь объявленим функций, вызываемых при принятии и отправке пакета:
```cpp
esp_now_register_recv_cb(OnDataRecv);
esp_now_register_send_cb(OnDataSent);
```  
и непосредственно функцией отправки пакета:
```cpp
esp_now_send(mac_addr, (uint8_t *) &to_switch, sizeof(to_switch));
  ```
 ограничиваясь, таким образом, лишь памятью ESP-12f, где хранятся MAC адреса добавленных устройств.
 
Также стоит отметить, чтобы функции [ESP-NOW](https://www.espressif.com/en/products/software/esp-now/overview) отрабатывались без ошибок, оба устройства должны быть установлены на один и тот же канал Wi-Fi. Устройства время от времени сканируют сеть, выбирают точку доступа MYEWWT, или точку доступа домашней сети Wi-Fi при недоступности сети MYEWWT, и настраиваются на её канал. При этом подключение к самой точке доступа не требуется. 

<a id="structure"></a>
# Структуры для связи по ESP-NOW

Управление с помощью [ESP-NOW](https://www.espressif.com/en/products/software/esp-now/overview) происходит благодаря созданию структур, в которых присутствуют несколько основных переменных. ID, value, SSID и password.

SSID и password необходимы для обмена между устройствами данными об основной точке доступа Wi-Fi, чтобы устройство могло настроиться на канал и/или соединиться с сервером для обновления прошивки.

Несколько различных структур в зависимости от передающего и принимающего устройства:
* to_relay (на принимающем устройстве from_MYEWWT),
* to_switch (на принимающем устройстве from_MYEWWT),
* to_MYEWWT (на принимающем устройстве from_device).

Структуры с переменными в коде: 
```cpp
  struct {
   byte ID;
   byte value;
   char WIFI_ROUTER_SSID[35];
   } to_relay

   struct {
   byte ID;
   char WIFI_ROUTER_SSID[35];
   uint8_t Address[6];
   } to_switch;

   struct {
   byte ID;
   byte value;
   } to_MYEWWT
```

ID:
- 0 — запрос на настройку к MYEWWT от прибора,
- 1 — запрос от MYEWWT к прибору,
- 2 — запрос на настройку к MYEWWT от выключателя,
- 3 — отчет об успешной настройке к MYEWWT от выключателя,
- 4 — запрос к прибору от выключателя,
- 5 — отправка данных к выключателю от MYEWWT,
- 6 — уведомление об открытой двери,
- 7 — отчет о получении уведомления открытой двери.

value:
- 0 — выключено,
- 1 — включено,
- 2 — запрос на включение/выключение,
- 3 — запрос состояния.


<a id="unicode"></a>
## Конвертер из Юникода

Помимо прочих, в проекте используются библиотека FastBot от AlexGyver, для удобного парсинга сообщений от бота. Функционал MYEWWT предполагает использование смайликов и киррилических символов, но при обращении с API Telegram обработчик получает Юникод, поэтому библиотека FastBot была доработана — дописана функция конвертации символов Юникода в UTF-8.

В википедии найдены [алгоритмы преобразования юникода в utf-8](https://ru.wikipedia.org/wiki/UTF-8#%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%BA%D0%BE%D0%B4%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F). Нужно определить, сколько октетов используется, в соответствии с этим создать шаблоны в битовом выражении, далее побитно включить или выключить нужные биты в шаблоне, затем с помощью логического умножения взять маской биты и включить, после этого преобразовать в последовательность символов HEX системы. В результате успешно получаем русский, индийский и прочие алфавиты.

С другими символами и смайлами ситуация обстоит немного иначе: UTF-8 может занимать и 4 бита, кодируя в принципе весь диапазон юникода, но во входящем сообщении от Telegram мы видим [суррогатные пары UTF-16](https://ru.wikipedia.org/wiki/UTF-16). Если коротко, цельные байты UTF-8 разбиваются на две пары — верхняя и нижняя часть суррогатной пары. Её нам нужно восстановить в цельный юникод по формуле, чтобы затем преобразовать в уже знакомую нам последовательность HEX в utf-8.

```cpp
String convertUnicode(String unicodeStr) {
  String out = "";
  int len = unicodeStr.length();
  char iChar;
  char* error;
  int32_t unicode_bytes; //переменная для числовой записи байтов юникода
  int32_t surr_bytes1; // верхняя часть суррогатной пары
  int32_t surr_bytes2; // нижняя часть суррогатной пары
  for (int i = 0; i < len; i++) {
    iChar = unicodeStr[i];
    if (iChar == '\\') {
      iChar = unicodeStr[++i];
      if (iChar == 'u') {
        char unicode[6];
        unicode[0] = '0';
        unicode[1] = 'x';
        for (int j = 0; j < 4; j++) {
          iChar = unicodeStr[++i];
          unicode[j + 2] = iChar;
        }

        unicode_bytes = strtol(unicode, &error, HEX); //получаем число - юникод в hex

        if ((unicode_bytes >= 0xD800) && (unicode_bytes <= 0xDBFF)) { //если находим первую кодовую единицу суррогатной пары
          surr_bytes1 = unicode_bytes;
        }
        
        else if ((unicode_bytes >= 0xDC00) && (unicode_bytes <= 0xDFFF)) { //если находим вторую кодовую единицу суррогатной пары

          surr_bytes2 = unicode_bytes;
          unicode_bytes = (0x10000 + ((surr_bytes1 - 0xD800) * 0x0400) + (surr_bytes2 - 0xDC00)); //собираем из суррогатной пары полный юникод

          //собираем по алгоритму для 4 октетов
          byte myByte1 = unicode_bytes & 0b111111;
          bitSet(myByte1, 7);
          bitClear(myByte1, 6);

          unicode_bytes >>= 6;
          byte myByte2 = unicode_bytes & 0b111111;
          bitSet(myByte2, 7);
          bitClear(myByte2, 6);

          unicode_bytes >>= 6;
          byte myByte3 = unicode_bytes & 0b111111;
          bitSet(myByte3, 7);
          bitClear(myByte3, 6);

          unicode_bytes >>= 6;
          byte myByte4 = unicode_bytes & 0b111;
          bitSet(myByte4, 7);
          bitSet(myByte4, 6);
          bitSet(myByte4, 5);
          bitSet(myByte4, 4);
          bitClear(myByte4, 3);

          out += (char)myByte4;
          out += "\0x";
          out += (char)myByte3;
          out += "\0x";
          out += (char)myByte2;
          out += "\0x";
          out += (char)myByte1;
        }

        else if (unicode_bytes < 0x800) { //если требуется 2 октета
          byte myByte1 = unicode_bytes & 0b111111;
          bitSet(myByte1, 7);
          bitClear(myByte1, 6);

          unicode_bytes >>= 6;
          byte myByte2 = unicode_bytes & 0b11111;
          bitSet(myByte2, 7);
          bitSet(myByte2, 6);
          bitClear(myByte2, 5);

          out += (char)myByte2;
          out += "\0x";
          out += (char)myByte1;
        }
        else if (unicode_bytes >= 0x800) { //если требуется три октета

          byte myByte1 = unicode_bytes & 0b111111;
          bitSet(myByte1, 7);
          bitClear(myByte1, 6);

          unicode_bytes >>= 6;
          byte myByte2 = unicode_bytes & 0b111111;
          bitSet(myByte2, 7);
          bitClear(myByte2, 6);
          
          unicode_bytes >>= 6;
          byte myByte3 = unicode_bytes & 0b1111;
          bitSet(myByte3, 7);
          bitSet(myByte3, 6);
          bitSet(myByte3, 5);
          bitClear(myByte3, 4);

          out += (char)myByte3;
          out += "\0x";
          out += (char)myByte2;
          out += "\0x";
          out += (char)myByte1;
        }
      } else if (iChar == '/') {
        out += iChar;
      } else if (iChar == 'n') {
        out += '\n';
      }
    } else {
      out += iChar;
    }
  }
  return out;
}
```


# Умный выключатель zhukov technologies
Беспроводной сенсорный выключатель это устройство системы умного дома на основе API Telegram.

![DSC06544](https://user-images.githubusercontent.com/84660518/156888964-e295e8a9-c531-4ee4-bc5f-3f1df61e0288.jpg)


## Содержание
- [Умный выключатель zhukov technologies](#switch)
- [Подробнее о системе и коде](#code)
- [Плата и основные компоненты](#components)
- [Схема и работа печатной платы](#scheme)
- [Ответственность](#responsibility)
- [Контакты](#contacts)


<a id="switch"></a>
# Умный выключатель реле zhukov technologies

Выключатель — один из компонентов системы умного дома zhukov technologies. Управляет [реле и розетками](https://github.com/zhukov-technologies/zhukov_socket_and_relay) c помощью [ESP-NOW](https://www.espressif.com/en/products/software/esp-now/overview).

О системе умного дома zhukov technologies: 

Шлюзом системы является [розетка или реле](https://github.com/zhukov-technologies/zhukov_myewwt_clock), настроенные в режим шлюза.

Шлюз взаимодействует c API Telegram, позволяя пользователю отправлять команды и предоставляет на них ответ в Telegram-боте, заренее созданном пользователем. 

Шлюз подключается к Интернету через WI-Fi и взаимодействует с Telegram ботом, получая команды от него, обрабатывает их и управляет реле и розеткой с помощью технологии [ESP-NOW.](https://www.espressif.com/en/products/software/esp-now/overview)



Возможности шлюза-розетки.

* соединение с точкой доступа Wi-Fi и выход в интернет,
* обмен данными с другими устройствами умного дома с применением технологии [ESP-NOW](https://www.espressif.com/en/products/software/esp-now/overview).


<a id="code"></a>
# Подробнее о системе и коде
Здесь и далее находится описание выключателя. Информацию о системе умного дома , особенностях кода прошивки вы можете найти [здесь](https://github.com/zhukov-technologies/zhukov_socket_and_relay/blob/main/ABOUT.md).

<a id="components"></a>
# Плата и основные компоненты

![Безымянный3](https://user-images.githubusercontent.com/84660518/156888202-56f70ef1-fd2b-4216-8583-a68bb003adaa.png)


Основные компоненты:
 * микроконтроллер Espressif ESP-12F,
 * сенсорные модули ttp-223,
 * батарейный отсек

<a id="scheme"></a>
# Схема и работа печатной платы

![Schematic_switch_2022-03-04](https://user-images.githubusercontent.com/84660518/156888193-6b77c75f-477e-4969-9431-6295f0271405.png)


На плату подаётся питание 3 В от батарейного отсека, в котором находятся две батарейки типа ААА. Питание микроконтроллера осуществляется с помощью режима Power-Down, при котором потребление самого микроконтроллера составляет 3 мкА. Каждый сенсорный модуль потребляет 2 мкА, в сумме весь выключатель в режиме ожидания потребляет ~7мкА, чего хватает на долгое время (от нескольких месяцев до нескольких лет в зависимости от используемых батареек).

В режим Power-Down микроконтроллер ESP-12F вводится благодаря отключению питания с пина EN. 

Логика работы выключателя следующая: при нажатии на кнопку высокий уровень (HIGH) подается на GPIO0, GPIO2 и на пин EN, что запускает микроконтроллер. При включении в коде прошивки HIGH подаётся на GPIO0:
```cpp
pinMode(0, OUTPUT);
digitalWrite(0, HIGH);
```
это нужно для поддержания питания на пине EN даже при незажатой кнопке. Помимо этого, HIGH подаётся также на GPIO14 или GPIO4 в зависимости от нажатой кнопки, для того, чтобы микроконтроллер смог определить какая кнопка была нажата и поднять соответствующий флаг butt1 или butt2:
```cpp
butt1 = digitalRead(14);
butt2 = !butt1;
```

Затем, после отработки цикла (отправки запроса на включение или выключение устройства), микроконтроллер переводит пин GPIO0 в LOW, что в результате переводит пин EN также в LOW, а микроконтроллер в режим Power-Down. На случай, если кнопка не была отпущена, в качестве защитной меры микроконтроллер дополнительно вводится в режим Deep-Sleep командой deepSleepInstant. 

```cpp
digitalWrite(0, LOW);
ESP.deepSleepInstant(0);
```
p.s. (system_deep_sleep() назначает таймер с процедурой system_deep_sleep_instant() через 100 мс, соответственно, используя напрямую данную команду мы экономим 100 мс)


<a id="responsibility"></a>
# Ответственность

В прошивке выключателя используются библиотеки из проектов с открытым исходным кодом на основании лицензий, закреплёнными за авторами библиотек. Таким образом, работоспособность библиотек не может быть гарантирована. Также нет никаких гарантий, что устройство будет работать с вашей электросетью, и вы не получите ущерба во время эксплуатации устройства.

[Лицензия GNU General Public License v3.0](https://github.com/zhukov-technologies/zhukov_switch/blob/main/LICENSE.md)

<a id="contacts"></a>
# Контакты

https://zhukov-tech.ru
